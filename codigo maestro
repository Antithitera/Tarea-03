#include <iostream>
#include <cmath>
using namespace std;

/*
EQUIPO V-03
ANGEL TABUENCA
CARLOS ASENSIO
MERCEDES ANDUEZA

DESCRIPCIÓN
*/
const double pi=(4*atan(1)), epsilon=pow(10,-7);

void validaAngulo (double theta_0, char utheta, bool &b, double &theta0){//Devuelve theta_0 en radianes -> USAR theta0
    if (utheta=='s'){
        theta0=theta_0*pi/180;
        b=false;}
    else if (utheta=='r'){
        b=true;
        theta0=theta_0;}
}

void validaVelocidad (double omega_0, char uomega, bool &b, double &omega0){//Devuelve omega_0 en radianes -> USAR omega0
if (uomega=='s'){
    omega_0=omega_0*pi/180;
    b=false;}
else if (uomega=='r'){
    b=true;
    omega_0=omega_0;}
}

double fase (double s, double r, double &phi0){//Falta terminar el else para que cos() tenga el mismo signo que r
    if(s>=1)   
        return pi/2;
    else if (s<=-1)   
        return -pi/2;
    else {
      phi0=asin(s);
    }
}

double normaliza (double theta){//Hay que normalizar los ángulos mostrados por pantalla
    double n, thetaprima;
    n=(theta+pi)/(2*pi);
    thetaprima=theta-2*n*pi;
return thetaprima;
}

void analisis (double alpha, double theta_0, double omega_0, double epsilon, double &thetaM, double &tau, int &k){
double omega, m, g, l;
int n, i;
double a[n];
if (E>2mgl){
    k=-1;
    tehtaM=pi;
    A=sqrt(omega_0*omega_0+2*alpha*(1-cos(theta_0)))/2;
    r=sqrt(alpha)/A;
    tau_0=pi/A;
    Z=0;
    a[0]=1
    for(i=0;i<=n;i++){
    j=i+1
    a[j]=pow((2*j-1)*r/2/j,2)
    Z=a[i]+Z;
    }
    tau=tau_0*Z;//denomino a lo que en los apuntes llama T0 como tau_0 porque dice que en estos casos tau es el periodo
}
else if (E<2mgl){
    thetaM=acos(cos(theta_0)-pow(omega_0,2));
    k=1;
    tau_0=2*pi/2/alpha;
    r=sin(thetaM/2);
    Z=0;
    a[0]=1
    for(i=0;i<=n;i++){
    j=i+1
    a[j]=pow((2*j-1)*r/2/j,2)
    Z=a[i]+Z;
    }
    tau=tau_0*Z;
}
else if (E=2mgl && omega_0>=0){
    theta=0.999*pi;
    thetaM=pi;
    U=tan(omega/4+pi/4);
    C=1/tan(omega_0/4+pi/4);
    tau=ln(C*U)/sqrt(alpha);   
    k=0;
}
else{
    theta=-0.999*pi;
    thetaM=-pi;
    U=tan(omega/4+pi/4);
    C=1/tan(omega_0/4+pi/4);
    tau=-ln(C*U)/sqrt(alpha);
    k=0;
}
}

void rungekutta (double aplha, double &v, double &thetaT, double delta){
//Aquí tienen que estar también los cout cada tcout iteraciones y una función si la energía es menor que 2mgl.
}

int main(){
    double fd, fcout, fsimul, theta0, theta_0, omega0, omega_0, alpha, thetaM, tau, k,td, tcout, tsimul; //NOTA: omega0 es la velocidad angular inicial, theta^punto_0.
    char utheta, uomega;
    cin>>fd>>fcout>>fsimul>>theta_0>>utheta>>omega_0>>uomega>>alpha;
    //Mensaje de error si alguna unidad está mal
    if (alpha<=0||fd<=0||fcout<=0||fsimul<=0||(utheta!='r' && utheta!='s')||(uomega!='r' && uomega!='s'))
        cout << "HAY ALGÚN ERROR, ALPHA Y LOS FACTORES DEL PERIODO DEBEN SER POSITIVOS Y LAS UNIDADES DEL ÁNGULO Y LA VELOCIDAD DEBEN SER 'r' O 's'.";
    //Nos aseguremos de que theta y omega estén en radianes
    validaAngulo(theta_0,utheta,b,theta0);
    validaVelocidad(omega_0,uomega,b,omega0);

    else {
        analisis(aplpha,theta0,omega0,epsilon,thetaM,tau,k);
        //Calculamos los tiempos representativos del péndulo gracias a la tau que calcula el subalgoritmo analisis
        td=fd*tau;
        tcout=fd*tau;
        tsimul=fsimul*tau;
        //Usamos RungeKutta para calcular theta y omega para sucesivos tiempos hasta t=tsimul

    }
return 0;
}

